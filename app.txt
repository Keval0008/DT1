import pandas as pd
import networkx as nx
from typing import Tuple, List

class LineageTracer:
    def __init__(self, lineage_df: pd.DataFrame):
        """Initialize with pre-built graph"""
        self.lineage_df = lineage_df
        self.reverse_df = lineage_df.rename(columns={
            'main_table_name': 'derivation_table_name',
            'main_variable_name': 'derivation_variable_name',
            'derivation_table_name': 'main_table_name',
            'derivation_variable_name': 'main_variable_name'
        })
        self.G = self._build_graph()

    def _build_graph(self) -> nx.DiGraph:
        """Build directed graph once during initialization"""
        G = nx.DiGraph()
        for _, row in self.lineage_df.iterrows():
            source = f"{row['derivation_table_name']}.{row['derivation_variable_name']}"
            target = f"{row['main_table_name']}.{row['main_variable_name']}"
            G.add_edge(source, target)
        return G

    def trace_lineage(
        self,
        starting_tables: List[str],
        starting_columns: List[str],
        direction: str = 'downstream'  # 'upstream' or 'downstream'
    ) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
        """
        Trace lineage from starting points
        
        Returns:
            Tuple of (full_trace_df, source_nodes_df, dead_ends_df)
        """
        start_nodes = [f"{t}.{c}" for t, c in zip(starting_tables, starting_columns)]
        
        # Get relevant nodes
        if direction == 'upstream':
            relevant_nodes = set()
            for node in start_nodes:
                if node in self.G:
                    relevant_nodes.update(nx.ancestors(self.G, node))
            relevant_nodes.update(start_nodes)
            df_to_use = self.reverse_df
            id_cols = ['derivation_table_name', 'derivation_variable_name']
        else:  # downstream
            relevant_nodes = set()
            for node in start_nodes:
                if node in self.G:
                    relevant_nodes.update(nx.descendants(self.G, node))
            relevant_nodes.update(start_nodes)
            df_to_use = self.lineage_df
            id_cols = ['main_table_name', 'main_variable_name']

        # Filter DataFrame
        mask = df_to_use[id_cols[0]] + '.' + df_to_use[id_cols[1]].isin(relevant_nodes)
        traced_df = df_to_use[mask].copy()

        # Find dead ends
        dead_ends = []
        for node in relevant_nodes:
            if direction == 'upstream' and self.G.in_degree(node) == 0:
                dead_ends.append(node)
            elif direction == 'downstream' and self.G.out_degree(node) == 0:
                dead_ends.append(node)

        # Create output DataFrames
        dead_ends_df = pd.DataFrame(
            [n.split('.') for n in dead_ends],
            columns=['Source Table', 'Source Column']
        )

        source_nodes_df = self._identify_source_nodes(traced_df, direction)
        
        return traced_df, source_nodes_df, dead_ends_df

    def _identify_source_nodes(self, df: pd.DataFrame, direction: str) -> pd.DataFrame:
        """Identify source tables based on naming patterns"""
        keywords = ['source', 'repair', 'intra', 'detail', 'union']
        pattern = '|'.join(keywords)
        
        if direction == 'upstream':
            col = 'derivation_table_name'
            return df[df[col].str.contains(pattern, case=False)][[col, 'derivation_variable_name']]\
                .rename(columns={col: 'Source Table', 'derivation_variable_name': 'Source Column'})
        else:
            col = 'main_table_name'
            return df[df[col].str.contains(pattern, case=False)][[col, 'main_variable_name']]\
                .rename(columns={col: 'Source Table', 'main_variable_name': 'Source Column'})
