import os
import uuid
from datetime import datetime

import dash
from dash import dcc, html, Input, Output, State, dash_table, callback_context, no_update
import pandas as pd

from services.file_io import save_uploaded_xlsx, ensure_session_dir, cleanup_session_dir
from services.run_date_parser import extract_run_date_from_xlsx
from services.schema_detector import detect_header_row, build_column_options
from services.diff_engine import run_reference_check
from services.report_writer import write_anomaly_report_xlsx
from utils.constants import EXPECTED_COLUMNS_DEFAULT, HEADER_SCAN_ROWS_MAX, HEADER_SCAN_COLS_MAX

APP_TITLE = "Data Check Tool"

app = dash.Dash(__name__, title=APP_TITLE)
server = app.server


def _empty_table_df():
    return pd.DataFrame(columns=["filename", "run_date", "status", "file_id", "valid"])


app.layout = html.Div(
    style={"maxWidth": "1200px", "margin": "20px auto", "fontFamily": "Arial"},
    children=[
        html.H2(APP_TITLE),
        dcc.Tabs(
            id="tabs",
            value="tab_reference",
            children=[
                dcc.Tab(label="Reference Data Check", value="tab_reference"),
                dcc.Tab(label="Financial Data Check", value="tab_financial"),
            ],
        ),

        # Global stores
        dcc.Store(id="session_store", storage_type="memory"),
        dcc.Store(id="files_store", storage_type="memory"),  # list of file metadata
        dcc.Store(id="meta_store", storage_type="memory"),   # run dates + current file id
        dcc.Store(id="schema_store", storage_type="memory"), # header rows, available columns
        dcc.Store(id="diff_store", storage_type="memory"),   # anomaly df + summary
        dcc.Store(id="report_path_store", storage_type="memory"),

        html.Div(id="tab_content", style={"marginTop": "16px"}),

        dcc.Download(id="download_report"),
    ],
)


def render_reference_tab():
    return html.Div(
        children=[
            html.Div(
                style={"display": "flex", "gap": "16px", "alignItems": "flex-start"},
                children=[
                    html.Div(
                        style={"flex": "1", "border": "1px solid #ddd", "borderRadius": "8px", "padding": "14px"},
                        children=[
                            html.H4("1) Upload xlsx files"),
                            dcc.Upload(
                                id="upload_xlsx",
                                children=html.Div(["Drag & drop or ", html.A("select files")]),
                                multiple=True,
                                style={
                                    "width": "100%",
                                    "height": "72px",
                                    "lineHeight": "72px",
                                    "borderWidth": "1px",
                                    "borderStyle": "dashed",
                                    "borderRadius": "8px",
                                    "textAlign": "center",
                                    "cursor": "pointer",
                                },
                            ),
                            html.Div(id="upload_status", style={"marginTop": "10px", "color": "#333"}),
                            html.Div(
                                style={"marginTop": "12px", "display": "flex", "gap": "10px"},
                                children=[
                                    html.Button("Clear Session", id="clear_session_btn"),
                                ],
                            ),
                        ],
                    ),
                    html.Div(
                        style={"flex": "1", "border": "1px solid #ddd", "borderRadius": "8px", "padding": "14px"},
                        children=[
                            html.H4("2) Pick reference + settings"),
                            html.Div(id="current_file_text", style={"marginBottom": "10px"}),
                            html.Label("Reference file (previous runs)"),
                            dcc.Dropdown(
                                id="reference_file_dropdown",
                                options=[],
                                placeholder="Upload files first",
                                clearable=False,
                            ),
                            html.Div(style={"height": "10px"}),

                            html.Label("Key column (must exist in both)"),
                            dcc.Input(
                                id="key_column_input",
                                type="text",
                                placeholder="e.g. customer_id",
                                style={"width": "100%"},
                            ),
                            html.Div(style={"height": "10px"}),

                            html.Label("Columns to compare (optional: empty = auto)"),
                            dcc.Dropdown(
                                id="compare_columns_dropdown",
                                options=[],
                                multi=True,
                                placeholder="Auto uses EXPECTED_COLUMNS",
                            ),

                            html.Div(style={"height": "12px"}),

                            html.Details(
                                children=[
                                    html.Summary("Header detection (optional override)"),
                                    html.Div(style={"height": "8px"}),
                                    html.Div(
                                        style={"display": "flex", "gap": "10px"},
                                        children=[
                                            html.Div(
                                                style={"flex": 1},
                                                children=[
                                                    html.Label("Main header row override (1-based)"),
                                                    dcc.Input(
                                                        id="main_header_override",
                                                        type="number",
                                                        min=1,
                                                        step=1,
                                                        placeholder="Leave empty for auto",
                                                        style={"width": "100%"},
                                                    ),
                                                ],
                                            ),
                                            html.Div(
                                                style={"flex": 1},
                                                children=[
                                                    html.Label("Reference header row override (1-based)"),
                                                    dcc.Input(
                                                        id="ref_header_override",
                                                        type="number",
                                                        min=1,
                                                        step=1,
                                                        placeholder="Leave empty for auto",
                                                        style={"width": "100%"},
                                                    ),
                                                ],
                                            ),
                                        ],
                                    ),
                                ],
                                style={"marginTop": "10px"},
                            ),

                            html.Div(style={"height": "12px"}),

                            html.Button("Run Comparison", id="run_compare_btn", style={"width": "100%"}),
                            html.Div(id="run_compare_status", style={"marginTop": "10px", "color": "#333"}),
                        ],
                    ),
                ],
            ),

            html.Div(style={"height": "16px"}),

            html.Div(
                style={"border": "1px solid #ddd", "borderRadius": "8px", "padding": "14px"},
                children=[
                    html.H4("Uploaded files"),
                    dash_table.DataTable(
                        id="files_table",
                        columns=[
                            {"name": "Filename", "id": "filename"},
                            {"name": "Run Date", "id": "run_date"},
                            {"name": "Status", "id": "status"},
                            {"name": "Valid", "id": "valid"},
                        ],
                        data=_empty_table_df().to_dict("records"),
                        page_size=8,
                        style_table={"overflowX": "auto"},
                        style_cell={"padding": "8px", "fontSize": "13px"},
                        style_header={"fontWeight": "bold"},
                    ),
                ],
            ),

            html.Div(style={"height": "16px"}),

            html.Div(
                style={"display": "flex", "gap": "16px"},
                children=[
                    html.Div(
                        style={"flex": "1", "border": "1px solid #ddd", "borderRadius": "8px", "padding": "14px"},
                        children=[
                            html.H4("Summary"),
                            html.Div(id="summary_cards"),
                            html.Div(style={"height": "12px"}),
                            html.Button("Download Anomaly Report (xlsx)", id="download_btn"),
                            html.Div(id="download_hint", style={"marginTop": "8px", "fontSize": "12px", "color": "#555"}),
                        ],
                    ),
                    html.Div(
                        style={"flex": "2", "border": "1px solid #ddd", "borderRadius": "8px", "padding": "14px"},
                        children=[
                            html.H4("Anomalies"),
                            dash_table.DataTable(
                                id="anomaly_table",
                                columns=[
                                    {"name": "Change", "id": "change_type"},
                                    {"name": "Key", "id": "key"},
                                    {"name": "Column", "id": "column_name"},
                                    {"name": "Old", "id": "old_value"},
                                    {"name": "New", "id": "new_value"},
                                ],
                                data=[],
                                page_size=12,
                                filter_action="native",
                                sort_action="native",
                                style_table={"overflowX": "auto"},
                                style_cell={"padding": "8px", "fontSize": "13px", "maxWidth": "240px", "overflow": "hidden", "textOverflow": "ellipsis"},
                                style_header={"fontWeight": "bold"},
                            ),
                        ],
                    ),
                ],
            ),
        ]
    )


def render_financial_tab():
    return html.Div(
        style={"border": "1px solid #ddd", "borderRadius": "8px", "padding": "14px"},
        children=[
            html.H4("Financial Data Check"),
            html.Div("Placeholder. We can reuse the same pipeline and add numeric tolerance + aggregation rules here."),
        ],
    )


@app.callback(
    Output("tab_content", "children"),
    Input("tabs", "value"),
)
def switch_tab(tab_value):
    if tab_value == "tab_reference":
        return render_reference_tab()
    return render_financial_tab()


@app.callback(
    Output("session_store", "data"),
    Output("files_store", "data"),
    Output("meta_store", "data"),
    Output("schema_store", "data"),
    Output("diff_store", "data"),
    Output("report_path_store", "data"),
    Output("upload_status", "children"),
    Output("run_compare_status", "children"),
    Input("upload_xlsx", "contents"),
    Input("upload_xlsx", "filename"),
    Input("clear_session_btn", "n_clicks"),
    State("session_store", "data"),
    prevent_initial_call=True,
)
def handle_upload(contents_list, filename_list, clear_clicks, session_data):
    trig = callback_context.triggered[0]["prop_id"].split(".")[0]

    # Clear session
    if trig == "clear_session_btn":
        if session_data and session_data.get("session_id"):
            cleanup_session_dir(session_data["session_id"])
        return None, None, None, None, None, None, "Session cleared.", ""

    # Upload
    if not contents_list or not filename_list:
        return no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update

    session_id = (session_data or {}).get("session_id") or str(uuid.uuid4())
    ensure_session_dir(session_id)

    files_meta = []
    rows = []
    invalid_count = 0

    for content, fname in zip(contents_list, filename_list):
        file_id = str(uuid.uuid4())
        saved_path = save_uploaded_xlsx(session_id, file_id, fname, content)

        try:
            rd = extract_run_date_from_xlsx(saved_path)
            valid = rd["valid"]
            if not valid:
                invalid_count += 1
            run_date_str = rd["run_date_parsed"].strftime("%Y-%m-%d %H:%M:%S") if rd["run_date_parsed"] else ""
        except Exception:
            valid = False
            invalid_count += 1
            run_date_str = ""

        files_meta.append(
            {
                "file_id": file_id,
                "filename": fname,
                "path": saved_path,
            }
        )
        rows.append(
            {
                "filename": fname,
                "run_date": run_date_str,
                "status": "Unknown",
                "file_id": file_id,
                "valid": "Yes" if valid else "No",
            }
        )

    # Determine main/current by latest run date among valid ones
    # Re-extract to sort reliably
    enriched = []
    for fm in files_meta:
        rd = extract_run_date_from_xlsx(fm["path"])
        enriched.append({**fm, **rd})

    valid_files = [e for e in enriched if e["valid"] and e["run_date_parsed"] is not None]
    if not valid_files:
        meta = {
            "session_id": session_id,
            "current_file_id": None,
            "files_enriched": enriched,
        }
        return (
            {"session_id": session_id},
            files_meta,
            meta,
            None,
            None,
            None,
            f"Uploaded {len(files_meta)} file(s). No valid run dates found in row 1.",
            "",
        )

    valid_files_sorted = sorted(valid_files, key=lambda x: x["run_date_parsed"])
    current = valid_files_sorted[-1]
    current_id = current["file_id"]

    # Update statuses
    for r in rows:
        if r["file_id"] == current_id:
            r["status"] = "Current (Main)"
        else:
            r["status"] = "Previous"

    meta = {
        "session_id": session_id,
        "current_file_id": current_id,
        "files_enriched": [
            {
                "file_id": e["file_id"],
                "filename": e["filename"],
                "path": e["path"],
                "valid": e["valid"],
                "run_date_raw": e["run_date_raw"],
                "run_date_parsed": e["run_date_parsed"].isoformat() if e["run_date_parsed"] else None,
            }
            for e in enriched
        ],
        "files_table_rows": rows,
    }

    msg = f"Uploaded {len(files_meta)} file(s)."
    if invalid_count:
        msg += f" ({invalid_count} file(s) had missing/invalid run date.)"

    return (
        {"session_id": session_id},
        files_meta,
        meta,
        None,
        None,
        None,
        msg,
        "",
    )


@app.callback(
    Output("files_table", "data"),
    Output("reference_file_dropdown", "options"),
    Output("current_file_text", "children"),
    Output("compare_columns_dropdown", "options"),
    Input("meta_store", "data"),
)
def refresh_file_ui(meta):
    if not meta:
        return _empty_table_df().to_dict("records"), [], "Current/Main file: —", []

    rows = meta.get("files_table_rows") or []
    current_id = meta.get("current_file_id")

    # Build ref dropdown options from previous valid files
    opts = []
    current_name = "—"
    for f in (meta.get("files_enriched") or []):
        if f["file_id"] == current_id:
            current_name = f["filename"]
            continue
        if f.get("valid") and f.get("run_date_parsed"):
            dt_str = f["run_date_parsed"].replace("T", " ")[:19]
            opts.append({"label": f"{f['filename']} (Run: {dt_str})", "value": f["file_id"]})

    # Column compare options (default from constants; later overwritten by detected)
    compare_opts = [{"label": c, "value": c} for c in EXPECTED_COLUMNS_DEFAULT]

    return rows, opts, f"Current/Main file: {current_name}", compare_opts


@app.callback(
    Output("schema_store", "data"),
    Output("run_compare_status", "children"),
    Input("reference_file_dropdown", "value"),
    Input("main_header_override", "value"),
    Input("ref_header_override", "value"),
    State("meta_store", "data"),
    prevent_initial_call=True,
)
def detect_schema(ref_file_id, main_override, ref_override, meta):
    if not meta or not meta.get("current_file_id"):
        return no_update, "Upload valid files first."

    if not ref_file_id:
        return no_update, "Select a reference file."

    current_id = meta["current_file_id"]
    files = {f["file_id"]: f for f in meta["files_enriched"]}

    main_path = files[current_id]["path"]
    ref_path = files[ref_file_id]["path"]

    expected_cols = EXPECTED_COLUMNS_DEFAULT

    try:
        main_header = int(main_override) if main_override else detect_header_row(
            main_path, expected_cols, max_rows=HEADER_SCAN_ROWS_MAX, max_cols=HEADER_SCAN_COLS_MAX
        )
        ref_header = int(ref_override) if ref_override else detect_header_row(
            ref_path, expected_cols, max_rows=HEADER_SCAN_ROWS_MAX, max_cols=HEADER_SCAN_COLS_MAX
        )
    except Exception as e:
        return no_update, f"Header detection failed: {e}"

    # Build dropdown options for compare columns from whichever file has more matches
    main_col_opts = build_column_options(main_path, main_header)
    ref_col_opts = build_column_options(ref_path, ref_header)

    # union
    union = sorted(set([o["value"] for o in main_col_opts] + [o["value"] for o in ref_col_opts]))
    union_opts = [{"label": c, "value": c} for c in union]

    schema = {
        "main_header_row": main_header,
        "ref_header_row": ref_header,
        "compare_column_options": union_opts,
    }

    return schema, f"Detected headers → Main: row {main_header}, Reference: row {ref_header}"


@app.callback(
    Output("compare_columns_dropdown", "options"),
    Input("schema_store", "data"),
    State("compare_columns_dropdown", "options"),
)
def refresh_compare_columns(schema, existing_opts):
    if schema and schema.get("compare_column_options"):
        return schema["compare_column_options"]
    return existing_opts


@app.callback(
    Output("diff_store", "data"),
    Output("report_path_store", "data"),
    Output("summary_cards", "children"),
    Output("anomaly_table", "data"),
    Output("run_compare_status", "children"),
    Input("run_compare_btn", "n_clicks"),
    State("meta_store", "data"),
    State("schema_store", "data"),
    State("reference_file_dropdown", "value"),
    State("key_column_input", "value"),
    State("compare_columns_dropdown", "value"),
    prevent_initial_call=True,
)
def run_comparison(n_clicks, meta, schema, ref_file_id, key_col, compare_cols_selected):
    if not meta or not meta.get("current_file_id"):
        return no_update, no_update, no_update, no_update, "Upload valid files first."

    if not ref_file_id:
        return no_update, no_update, no_update, no_update, "Select a reference file."

    if not key_col or not key_col.strip():
        return no_update, no_update, no_update, no_update, "Enter the key column name."

    files = {f["file_id"]: f for f in meta["files_enriched"]}
    current_id = meta["current_file_id"]
    main_info = files[current_id]
    ref_info = files[ref_file_id]

    main_header = (schema or {}).get("main_header_row")
    ref_header = (schema or {}).get("ref_header_row")
    if not main_header or not ref_header:
        # fallback auto
        main_header = detect_header_row(main_info["path"], EXPECTED_COLUMNS_DEFAULT, HEADER_SCAN_ROWS_MAX, HEADER_SCAN_COLS_MAX)
        ref_header = detect_header_row(ref_info["path"], EXPECTED_COLUMNS_DEFAULT, HEADER_SCAN_ROWS_MAX, HEADER_SCAN_COLS_MAX)

    compare_cols = compare_cols_selected if compare_cols_selected else EXPECTED_COLUMNS_DEFAULT

    try:
        result = run_reference_check(
            main_path=main_info["path"],
            ref_path=ref_info["path"],
            key_column=key_col.strip(),
            compare_columns=compare_cols,
            main_header_row=main_header,
            ref_header_row=ref_header,
            main_run_date=main_info.get("run_date_parsed"),
            ref_run_date=ref_info.get("run_date_parsed"),
            main_filename=main_info.get("filename"),
            ref_filename=ref_info.get("filename"),
        )
    except Exception as e:
        return no_update, no_update, no_update, no_update, f"Comparison failed: {e}"

    anomalies_df = result["anomalies_df"]
    summary = result["summary"]

    # Write report
    session_id = meta.get("session_id")
    out_dir = ensure_session_dir(session_id)
    report_path = os.path.join(out_dir, f"anomaly_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx")
    write_anomaly_report_xlsx(report_path, summary, anomalies_df)

    # UI summary
    cards = html.Div(
        style={"display": "flex", "gap": "12px", "flexWrap": "wrap"},
        children=[
            html.Div(style={"padding": "10px", "border": "1px solid #eee", "borderRadius": "8px"}, children=[
                html.Div("Added rows", style={"fontSize": "12px", "color": "#666"}),
                html.Div(str(summary["added_rows"]), style={"fontSize": "20px", "fontWeight": "bold"}),
            ]),
            html.Div(style={"padding": "10px", "border": "1px solid #eee", "borderRadius": "8px"}, children=[
                html.Div("Deleted rows", style={"fontSize": "12px", "color": "#666"}),
                html.Div(str(summary["deleted_rows"]), style={"fontSize": "20px", "fontWeight": "bold"}),
            ]),
            html.Div(style={"padding": "10px", "border": "1px solid #eee", "borderRadius": "8px"}, children=[
                html.Div("Modified rows", style={"fontSize": "12px", "color": "#666"}),
                html.Div(str(summary["modified_rows"]), style={"fontSize": "20px", "fontWeight": "bold"}),
            ]),
            html.Div(style={"padding": "10px", "border": "1px solid #eee", "borderRadius": "8px"}, children=[
                html.Div("Modified cells", style={"fontSize": "12px", "color": "#666"}),
                html.Div(str(summary["modified_cells"]), style={"fontSize": "20px", "fontWeight": "bold"}),
            ]),
        ],
    )

    anomalies_records = anomalies_df.head(5000).to_dict("records")  # safety cap for UI

    diff_store = {
        "summary": summary,
        "anomalies": anomalies_records,
    }

    report_store = {"report_path": report_path}

    return diff_store, report_store, cards, anomalies_records, "Done. Report generated."


@app.callback(
    Output("download_report", "data"),
    Output("download_hint", "children"),
    Input("download_btn", "n_clicks"),
    State("report_path_store", "data"),
    prevent_initial_call=True,
)
def download_report(n_clicks, report_store):
    if not report_store or not report_store.get("report_path"):
        return no_update, "Run comparison first to generate a report."

    path = report_store["report_path"]
    if not os.path.exists(path):
        return no_update, "Report file not found (session may have been cleared)."

    return dcc.send_file(path), f"Downloading: {os.path.basename(path)}"


if __name__ == "__main__":
    app.run_server(debug=True, port=8050)
