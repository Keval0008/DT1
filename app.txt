import os
import re
from concurrent.futures import ThreadPoolExecutor
from functools import lru_cache
from typing import Dict, List, Tuple
import pandas as pd
from sqlglot import parse_one, exp
from sqlglot.lineage import LineageRunner

class SQLLineageProcessor:
    def __init__(self, replacements: Dict[str, str] = None):
        """
        Initialize the SQL Lineage Processor.
        
        Args:
            replacements: Dictionary of string replacements to apply to SQL queries
        """
        self.replacements = replacements or {}
        self.master_lineage_df = pd.DataFrame()
    
    @lru_cache(maxsize=100)
    def parse_sql_cached(self, sql: str) -> exp.Expression:
        """Cached SQL parsing function."""
        return parse_one(sql, read='bigquery')
    
    def format_and_clean_sql(self, sql: str) -> str:
        """Formats and cleans SQL query for better readability and consistency."""
        try:
            parsed = self.parse_sql_cached(sql)
            formatted_sql = parsed.sql(pretty=True)
            return re.sub(r'/\*.*?\*/', ' ', formatted_sql, flags=re.DOTALL)
        except Exception as e:
            print(f"Warning: Formatting failed - {str(e)}")
            return sql
    
    @staticmethod
    def normalize_sql(sql: str) -> List[str]:
        """Normalizes SQL query by removing extra spaces and converting to lowercase."""
        return [re.sub(r'\s+', ' ', line.strip()).lower() 
                for line in sql.split('\n') if line.strip()]
    
    @staticmethod
    def clean_lineage_tuple(variable: List[str]) -> List[str]:
        """Cleans lineage tuples by removing default schema references."""
        return [v.replace('<default>.', '') for v in variable]
    
    def extract_column_lineage(self, processed_sql: str) -> pd.DataFrame:
        """Extracts column lineage from SQL query."""
        try:       
            # Extract lineage
            lineage_mapping = []
            for lineage_tuple in LineageRunner(processed_sql).get_column_lineage():
                try:
                    chain = [str(col) for col in lineage_tuple]
                    cleaned_chain = self.clean_lineage_tuple(chain)
                    
                    for i in range(len(cleaned_chain) - 1):
                        target = cleaned_chain[i]
                        source = cleaned_chain[i + 1]
                        
                        lineage_mapping.append((
                            target if len(target.split('.')) == 2 else f"<unknown>.{target}",
                            source if len(source.split('.')) == 2 else f"<unknown>.{source}"
                        ))
                except Exception as e:
                    print(f"Skipping lineage tuple due to error: {str(e)}")
                    continue
            
            # Create DataFrame
            lineage_df = pd.DataFrame(lineage_mapping, columns=["derived", "source"])
            lineage_df[['derived_table', 'derived_column']] = lineage_df['derived'].str.split('.', expand=True)
            lineage_df[['source_table', 'source_column']] = lineage_df['source'].str.split('.', expand=True)
            
            return lineage_df[['source_table', 'source_column', 'derived_table', 'derived_column']].drop_duplicates()
        
        except Exception as e:
            print(f"Lineage extraction failed: {str(e)}")
            return pd.DataFrame()
    
    def process_single_sql(self, sql: str, filename: str) -> Tuple[str, pd.DataFrame]:
        """Process a single SQL query string."""
        # Apply replacements
        for old, new in self.replacements.items():
            sql = sql.replace(old, new)
        
        # Clean and parse
        cleaned_sql = self.format_and_clean_sql(sql)
        ast = self.parse_sql_cached(cleaned_sql)
        final_sql = ast.sql()
        lineage_df = self.extract_column_lineage(final_sql)
        
        return final_sql, lineage_df
    
    def process_sql_file(self, file_path: str) -> pd.DataFrame:
        """Processes a single SQL file and returns lineage DataFrame."""
        try:
            with open(file_path, 'r') as f:
                sql = f.read().strip()
                if not sql:
                    print(f"Skipping empty file: {file_path}")
                    return pd.DataFrame()
                
                # Get just the filename without path
                filename = os.path.basename(file_path)
                _, lineage_df = self.process_single_sql(sql, filename)
                return lineage_df
        except Exception as e:
            print(f"Error processing {file_path}: {str(e)}")
            return pd.DataFrame()
    
    def process_sql_folder(self, folder_path: str) -> pd.DataFrame:
        """Processes all SQL files in a folder and returns combined lineage."""
        # Get all SQL files in the folder
        sql_files = [
            os.path.join(folder_path, f) 
            for f in os.listdir(folder_path) 
            if f.endswith('.sql')
        ]
        
        # Process files in parallel
        with ThreadPoolExecutor() as executor:
            results = list(executor.map(self.process_sql_file, sql_files))
        
        # Combine results and update master lineage
        combined_df = pd.concat(results).drop_duplicates().reset_index(drop=True)
        self.master_lineage_df = pd.concat([self.master_lineage_df, combined_df]).drop_duplicates().reset_index(drop=True)
        
        return self.master_lineage_df
    
    def get_master_lineage(self) -> pd.DataFrame:
        """Returns the accumulated master lineage DataFrame."""
        return self.master_lineage_df.copy()
    
    def reset_master_lineage(self) -> None:
        """Resets the master lineage DataFrame."""
        self.master_lineage_df = pd.DataFrame()
