# pip install --upgrade msoffcrypto-tool pandas openpyxl xlrd pyxlsb olefile cryptography
from typing import Union, Optional, Dict
from pathlib import Path
from getpass import getpass
import pandas as pd
import msoffcrypto
import zipfile
import olefile
import tempfile
import sys
import os

try:
    from msoffcrypto.exceptions import InvalidKeyError
except Exception:
    class InvalidKeyError(Exception):
        pass

SUPPORTED_EXCEL_EXTS = {".xlsx", ".xlsm", ".xls", ".xlsb"}
SUPPORTED_TEXT_EXTS  = {".csv", ".tsv"}

def _pick_engine(ext: str) -> str:
    ext = ext.lower()
    if ext in (".xlsx", ".xlsm"):
        return "openpyxl"
    if ext == ".xls":
        return "xlrd"
    if ext == ".xlsb":
        return "pyxlsb"
    raise ValueError(f"Unsupported Excel file type: {ext}")

def _file_signature(path: Path) -> bytes:
    with open(path, "rb") as f:
        return f.read(8)

def _ole_has_encryption_streams(path: Path) -> bool:
    """True if the OLE container has EncryptionInfo/EncryptedPackage streams."""
    if not olefile.isOleFile(str(path)):
        return False
    ole = olefile.OleFileIO(str(path))
    try:
        names = {"%s" % "/".join(parts) for parts in ole.listdir()}
        return ("EncryptionInfo" in names) or ("EncryptedPackage" in names)
    finally:
        ole.close()

def _is_probably_encrypted_excel(path: Path) -> Optional[bool]:
    """
    Robust encryption detection for Excel types.
    Returns True/False, or None if uncertain (we'll try normal read first).
    """
    ext = path.suffix.lower()
    sig = _file_signature(path)
    is_zip = sig.startswith(b"PK")  # OOXML .xlsx/.xlsm are plain ZIPs when not encrypted

    if ext in (".xlsx", ".xlsm"):
        # If it's a ZIP, it's a normal (not encrypted) OOXML workbook.
        # Encrypted OOXML usually comes as OLE "Binary Encrypted Package".
        if is_zip:
            return False
        return _ole_has_encryption_streams(path)

    if ext == ".xlsb":
        # Always OLE; check encryption streams
        return _ole_has_encryption_streams(path)

    if ext == ".xls":
        # Old binary format; leave as unknown. We'll try normal read first.
        return None

    return None

def _decrypt_to_temp(path: Path, password: str) -> str:
    """Decrypts using msoffcrypto to a temp file; returns temp file path."""
    ext = path.suffix.lower()
    with open(path, "rb") as f:
        of = msoffcrypto.OfficeFile(f)
        of.load_key(password=password)
        with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
            tmp_name = tmp.name
            of.decrypt(tmp)
    return tmp_name

def _read_csv_like(path: Path) -> pd.DataFrame:
    """
    Read CSV/TSV with a couple of sensible fallbacks for encoding and delimiter.
    """
    ext = path.suffix.lower()
    # choose delimiter
    sep = "\t" if ext == ".tsv" else ","

    # try a couple encodings
    for enc in ("utf-8", "utf-8-sig", "latin-1"):
        try:
            return pd.read_csv(path, sep=sep, encoding=enc)
        except UnicodeDecodeError:
            continue
    # last attempt lets pandas guess
    return pd.read_csv(path, sep=sep, engine=None)

def read_tablelike_any(
    path: Union[str, Path],
    password: Optional[str] = None,
    max_tries: int = 3
) -> Dict[str, pd.DataFrame]:
    """
    Generalized reader:
    - Excel (.xlsx, .xlsm, .xls, .xlsb): returns all sheets as {sheet_name: DataFrame}.
      If file is read-password protected, prompts for OPEN password (filename shown).
    - CSV/TSV: returns {file_stem: DataFrame}.

    Always returns a dict for consistency.
    """
    path = Path(path)
    ext = path.suffix.lower()

    # 1) Text formats: CSV/TSV (these cannot be password-protected by Excel)
    if ext in SUPPORTED_TEXT_EXTS:
        df = _read_csv_like(path)
        return {path.stem: df}

    # 2) Excel formats
    if ext not in SUPPORTED_EXCEL_EXTS:
        raise ValueError(
            f"Unsupported file type: {ext}. "
            f"Supported: {', '.join(sorted(SUPPORTED_TEXT_EXTS | SUPPORTED_EXCEL_EXTS))}"
        )

    engine = _pick_engine(ext)

    # Fast path: try to read directly (not encrypted, or .xls w/out protection)
    try:
        dfs = pd.read_excel(path, sheet_name=None, engine=engine)
        return dfs
    except Exception:
        # Determine if likely encrypted; for .xls treat unknown as possibly encrypted
        enc_guess = _is_probably_encrypted_excel(path)
        if enc_guess is False:
            # Not encrypted by our check â†’ raise the original error for visibility
            raise

        # Encrypted or uncertain: prompt and attempt decrypt-to-temp
        tries = 0
        last_err = None
        while tries < max_tries:
            pw = password or getpass(f"Enter OPEN password for '{path.name}': ")
            try:
                tmp_name = _decrypt_to_temp(path, pw)
                try:
                    dfs = pd.read_excel(tmp_name, sheet_name=None, engine=engine)
                    return dfs
                finally:
                    try:
                        os.remove(tmp_name)
                    except OSError:
                        pass
            except InvalidKeyError as e:
                print("Password incorrect. Please try again.", file=sys.stderr)
                last_err = e
                password = None
                tries += 1
            except Exception as e_dec:
                raise RuntimeError(f"Failed to decrypt '{path.name}': {e_dec}") from e_dec

        raise InvalidKeyError(f"Failed to open '{path.name}' after {max_tries} attempts (wrong password).") from last_err

# ----------------------- Examples -----------------------
# Excel (auto-detect; prompt if needed):
# sheets = read_tablelike_any("data.xlsx")
# for name, df in sheets.items():
#     print(name, df.shape)

# CSV:
# data = read_tablelike_any("data.csv")
# print(list(data.keys()))  # ['data']
# print(data['data'].head())
