# Implement the CET1 computation function described by you and demonstrate it on the uploaded CSV.
import pandas as pd
from typing import Dict, Union
from caas_jupyter_tools import display_dataframe_to_user

def compute_cet1(
    te_perc: Dict[str, float],
    rwa_perc: Dict[str, float],
    input_data: Union[pd.DataFrame, str],
    cgu_cols=("IWPB", "CIB", "CC"),
    category_col="category",
    amount_col="Amount",
    entity_col="entity",
) -> pd.DataFrame:
    """
    Compute CET1 per entity & business_line (CGU) using the rules:
      1) Start from 'Amount' as the total to split.
      2) If any specific split ratios are provided in CGU columns on a row, use those (ignore te/rwa).
         Ratios can be raw weights and will be normalized per row if needed.
      3) Else, if category contains 'adjustment' (case-insensitive), split by rwa_perc.
      4) Else, if category contains 'tangible' (case-insensitive), split by te_perc.
      5) Else, default to te_perc (fallback).
      6) Sum per entity & CGU.
      7) Output columns: entity, business_line, CET1, CET1 Adjustment (0).
    """
    # Load data if a path was provided
    if isinstance(input_data, str):
        df = pd.read_csv(input_data)
    else:
        df = input_data.copy()

    df = df.copy()

    # Ensure needed columns exist
    required_cols = {entity_col, category_col, amount_col}
    missing = required_cols - set(df.columns)
    if missing:
        raise ValueError(f"Missing required columns in input_data: {missing}")

    # Normalization helper for a dict-like mapping
    def normalize_map(m: Dict[str, float]) -> Dict[str, float]:
        s = sum(v for v in m.values() if pd.notna(v))
        if s == 0:
            # Avoid division by zero: fall back to equal split
            n = len(cgu_cols)
            return {k: 1.0 / n for k in cgu_cols}
        return {k: (m.get(k, 0.0) / s) for k in cgu_cols}

    te_w = normalize_map(te_perc)
    rwa_w = normalize_map(rwa_perc)

    # Prepare result accumulator
    out_records = []

    # Iterate rows and compute row-wise splits
    for idx, row in df.iterrows():
        amount = row.get(amount_col, 0.0)
        if pd.isna(amount):
            amount = 0.0

        # Check for explicit ratios in the row
        explicit_vals = {c: row[c] for c in cgu_cols if c in df.columns and pd.notna(row.get(c))}
        # Use explicit split if any of the CGU columns are non-null
        use_explicit = len(explicit_vals) > 0

        # Choose weights
        if use_explicit:
            w = normalize_map(explicit_vals)
        else:
            cat = str(row.get(category_col, "")).lower()
            if "adjustment" in cat:
                w = rwa_w
            elif "tangible" in cat:
                w = te_w
            else:
                # Fallback if neither matchesâ€”choose TE split as a sensible default
                w = te_w

        # Produce per-CGU split
        for cgu in cgu_cols:
            share = w.get(cgu, 0.0)
            cet1_part = amount * share
            out_records.append({
                "entity": row.get(entity_col),
                "business_line": cgu,
                "CET1": cet1_part,
                "CET1 Adjustment": 0.0,
            })

    # Aggregate
    out_df = (
        pd.DataFrame(out_records)
        .groupby(["entity", "business_line"], as_index=False)
        .agg({"CET1": "sum", "CET1 Adjustment": "sum"})
    )

    # Sort for readability
    order_map = {c: i for i, c in enumerate(cgu_cols)}
    out_df["business_order"] = out_df["business_line"].map(order_map)
    out_df = out_df.sort_values(["entity", "business_order"]).drop(columns=["business_order"])

    return out_df

# Demonstration: if user hasn't provided TE/RWA splits yet, we'll show an example with equal splits.
example_te = {"IWPB": 1/3, "CIB": 1/3, "CC": 1/3}
example_rwa = {"IWPB": 1/3, "CIB": 1/3, "CC": 1/3}

input_path = "/mnt/data/saracen.csv"
result_df = compute_cet1(example_te, example_rwa, input_path)

# Save and display
save_path = "/mnt/data/cet1_output_example.csv"
result_df.to_csv(save_path, index=False)
display_dataframe_to_user("CET1 Output (demo with equal TE/RWA splits)", result_df)

save_path
