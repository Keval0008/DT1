import dash
from dash import dcc, html, Input, Output, State, callback
import dash_bootstrap_components as dbc
from concurrent.futures import ThreadPoolExecutor
import pandas as pd
import os
import time

# Your existing SQLLineageProcessor class here

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

app.layout = dbc.Container([
    dcc.Input(id="folder-path", placeholder="Enter folder path", type="text"),
    dbc.Button("Generate Lineage", id="process-btn", color="primary"),
    html.Div(id="status-log", style={"whiteSpace": "pre-line", "margin": "10px"}),
    dbc.Progress(id="progress-bar", value=0, style={"margin": "10px"}),
    dcc.Loading(
        id="loading-spinner",
        type="circle",
        children=[html.Div()]
    ),
    dcc.Download(id="download-csv")
])

# Callback for processing + status updates
@app.callback(
    [Output("status-log", "children"),
     Output("progress-bar", "value"),
     Output("download-csv", "data")],
    Input("process-btn", "n_clicks"),
    State("folder-path", "value"),
    prevent_initial_call=True
)
def process_and_update_status(n_clicks, folder_path):
    if not folder_path:
        return "Error: No folder path provided", 0, None

    # Initialize processor
    processor = SQLLineageProcessor()
    
    # Stage 1: File discovery
    yield "ğŸ” Scanning folder for SQL files...", 10, None
    
    sql_files = [f for f in os.listdir(folder_path) if f.endswith('.sql')]
    if not sql_files:
        return "âŒ No SQL files found!", 0, None
    
    total_files = len(sql_files)
    yield f"ğŸ“‚ Found {total_files} files to process", 20, None

    # Stage 2: Parallel processing
    processed_count = 0
    yield f"âš™ï¸ Processing files (0/{total_files})", 20, None

    with ThreadPoolExecutor() as executor:
        futures = [executor.submit(processor.process_sql_file, os.path.join(folder_path, f)) 
                 for f in sql_files]
        
        while not all(f.done() for f in futures):
            new_processed = sum(1 for f in futures if f.done())
            if new_processed > processed_count:
                processed_count = new_processed
                progress = int(100 * (processed_count / total_files))
                yield f"âš™ï¸ Processing files ({processed_count}/{total_files})", 20 + (progress * 0.6), None
            time.sleep(0.1)

    # Stage 3: Compile results
    yield f"ğŸ§© Compiling results from {total_files} files...", 90, None

    master_lineage = processor.get_master_lineage()
    result_message = f"âœ… Done! Processed {total_files} files. Found {len(master_lineage)} lineage edges."
    
    # Return final status + CSV download
    return (
        result_message,
        100,
        dict(content=master_lineage.to_csv(index=False), filename="lineage_results.csv")
    )

if __name__ == "__main__":
    app.run_server(debug=True)
