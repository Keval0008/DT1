from sqllineage.runner import LineageRunner
import pandas as pd
import re
import sqlglot
from sqlglot import parse_one, exp
from rapidfuzz import fuzz
import os
from concurrent.futures import ThreadPoolExecutor
from functools import lru_cache
from typing import Dict, List, Optional, Tuple, Union
import pprint


# Cache parsed SQL to avoid redundant parsing
@lru_cache(maxsize=100)
def parse_sql_cached(sql: str) -> exp.Expression:
    return parse_one(sql, read='bigquery')

def format_and_clean_sql(sql: str) -> str:
    """Formats and cleans SQL query for better readability and consistency."""
    try:
        parsed = parse_sql_cached(sql)
        formatted_sql = parsed.sql(pretty=True)
        return re.sub(r'/\*.*?\*/', ' ', formatted_sql, flags=re.DOTALL)
    except Exception as e:
        print(f"Warning: Formatting failed - {str(e)}")
        return sql

def normalize_sql(sql: str) -> List[str]:
    """Normalizes SQL query by removing extra spaces and converting to lowercase."""
    return [re.sub(r'\s+', ' ', line.strip()).lower() 
            for line in sql.split('\n') if line.strip()]


def get_cte_schemas(ast: exp.Expression) -> dict:
    cte_schemas = {}
    
    if ast.args.get("with"):
        for cte in ast.args["with"].expressions:
            cte_name = cte.alias
            columns = {}
            source_tables = []
            source_ctes = []
            column_dependencies = {}

            # Process SELECT expressions in CTE
            for expr in cte.this.expressions:
                # Handle star expressions first (both qualified and unqualified)
                if isinstance(expr, exp.Star):
                    # Unqualified star (*)
                    col_name = "*"
                    col_expr = "*"
                    col_type = "star"
                elif isinstance(expr, exp.Column) and isinstance(expr.this, exp.Star):
                    # Qualified star (table.*)
                    col_name = "*"
                    col_expr = f"{expr.args['table']}.*"
                    col_type = "star"
                # Handle regular column references
                elif isinstance(expr, exp.Column):
                    col_name = expr.name
                    col_expr = expr.sql()
                    col_type = "column"
                # Handle aliased expressions
                elif isinstance(expr, exp.Alias):
                    col_name = expr.alias
                    # For aliased columns, get the underlying column reference
                    if isinstance(expr.this, exp.Column):
                        col_expr = expr.this.sql()
                        col_type = "column"
                    # For other aliased expressions (like CASE statements)
                    else:
                        col_expr = expr.this.sql()
                        col_type = "expression"
                # Handle all other expressions
                else:
                    col_name = f"expr_{len(columns) + 1}"
                    col_expr = expr.sql()
                    col_type = "expression"
                
                columns[col_name] = {
                    "type": col_type,
                    "expression": col_expr
                }
                column_dependencies[col_name] = [col_expr]

            # Identify source tables and CTEs
            from_clause = cte.this.args.get("from")
            if from_clause:
                for source in from_clause.expressions:
                    if isinstance(source, exp.Table):
                        table_name = source.name
                        alias = source.alias or table_name
                        source_tables.append(f"{table_name} AS {alias}" if alias != table_name else table_name)
                    elif isinstance(source, exp.Alias) and isinstance(source.this, exp.Table):
                        table_name = source.this.name
                        alias = source.alias
                        source_tables.append(f"{table_name} AS {alias}")

            # Check for CTE dependencies
            for src_cte in ast.args["with"].expressions:
                if src_cte.alias != cte_name and src_cte.alias in cte.this.sql():
                    source_ctes.append(src_cte.alias)

            cte_schemas[cte_name] = {
                "columns": columns,
                "source_tables": source_tables,
                "source_ctes": source_ctes,
                "column_dependencies": column_dependencies
            }
    
    return cte_schemas

def extract_main_table_schema(ast: exp.Expression, cte_names: set) -> dict:
    print("\n=== DEBUG: extract_main_table_schema ===")
    main_select = ast.find(exp.Select)
    if not main_select:
        print("DEBUG: No main SELECT found")
        return {}

    schema = {
        "main_select": {
            "from_table": {},
            "joins": {},
            "columns": {},
            "is_cte": {},
            "where": [],
            "group_by": [],
            "order_by": [],
            "join_conditions": []
        }
    }

    # Process FROM clause
    if main_select.args.get("from"):
        print("DEBUG: Processing FROM clause")
        from_clause = main_select.args["from"]
        
        if isinstance(from_clause, exp.From):
            sources = from_clause.expressions or [from_clause.this]
        else:
            sources = [from_clause]

        for source in sources:
            if isinstance(source, exp.Table):
                table_name = source.name
                alias = source.alias or table_name
                print(f"DEBUG: Found table {table_name} with alias {alias}")
                schema["main_select"]["from_table"][table_name] = alias
                schema["main_select"]["is_cte"][alias] = table_name in cte_names
            elif isinstance(source, exp.Alias) and isinstance(source.this, exp.Table):
                table_name = source.this.name
                alias = source.alias
                print(f"DEBUG: Found aliased table {table_name} as {alias}")
                schema["main_select"]["from_table"][table_name] = alias
                schema["main_select"]["is_cte"][alias] = table_name in cte_names


    # Process JOINs
    for join in main_select.args.get("joins", []):
        if isinstance(join.this, exp.Table):
            table_name = join.this.name
            alias = join.this.alias or table_name
            print(f"DEBUG: Found JOIN table {table_name} with alias {alias}")
            schema["main_select"]["joins"][table_name] = alias
            schema["main_select"]["is_cte"][alias] = table_name in cte_names
        elif isinstance(join.this, exp.Alias) and isinstance(join.this.this, exp.Table):
            table_name = join.this.this.name
            alias = join.this.alias
            print(f"DEBUG: Found aliased JOIN table {table_name} as {alias}")
            schema["main_select"]["joins"][table_name] = alias
            schema["main_select"]["is_cte"][alias] = table_name in cte_names

    # Process SELECT expressions
    print("\nDEBUG: Processing SELECT expressions")
    for i, expr in enumerate(main_select.expressions):
        print(f"\nDEBUG: Processing expression {i}: {expr.sql()}")
        print(f"DEBUG: Expression type: {type(expr)}")
        
        if isinstance(expr, exp.Star):
            print("DEBUG: Found unqualified star (*)")
            col_key = f"star_{i}"
            schema["main_select"]["columns"][col_key] = {
                "expression": "*",
                "is_star": True,
                "raw_expression": "*"
            }
        elif isinstance(expr, exp.Column) and isinstance(expr.this, exp.Star):
            print(f"DEBUG: Found qualified star ({expr.sql()})")
            col_key = f"star_{i}"
            table_ref = expr.args["table"].this if hasattr(expr.args["table"], 'this') else expr.args["table"]
            schema["main_select"]["columns"][col_key] = {
                "expression": f"{table_ref}.*",
                "is_star": True,
                "raw_expression": expr.sql()
            }
        else:
            if isinstance(expr, exp.Alias):
                col_name = expr.alias
                col_expr = expr.this.sql()
                print(f"DEBUG: Found aliased expression: {col_name} = {col_expr}")
            elif isinstance(expr, exp.Column):
                col_name = expr.name
                col_expr = expr.sql()
                print(f"DEBUG: Found column: {col_name}")
            else:
                col_name = f"expr_{i}"
                col_expr = expr.sql()
                print(f"DEBUG: Found complex expression: {col_name} = {col_expr}")
            
            schema["main_select"]["columns"][col_name] = {
                "expression": col_expr,
                "is_star": False,
                "raw_expression": expr.sql()
            }

    print("\nDEBUG: Final main schema:")
    pprint.pprint(schema)
    return schema

def resolve_recursive_schema(cte_schema: dict, main_schema: dict) -> dict:
    final_schema = {}
    print("\nDEBUG: Starting resolve_recursive_schema")  # Debug
    print(f"DEBUG: CTE Schema Keys: {cte_schema.keys()}")  # Debug
    print(f"DEBUG: Main Schema: {main_schema}")  # Debug

    def extract_alias_map(source_tables: list) -> dict:
        print(f"\nDEBUG: extract_alias_map input: {source_tables}")  # Debug
        alias_map = {}
        for table_def in source_tables:
            if " AS " in table_def:
                original, alias = [s.strip() for s in table_def.split(" AS ")]
                alias_map[alias] = original
            alias_map[table_def] = table_def.split(" AS ")[0]
        print(f"DEBUG: extract_alias_map output: {alias_map}")  # Debug
        return alias_map


    def resolve_cte(name: str) -> list:
        if name in final_schema:
            return final_schema[name]
        
        if name not in cte_schema:
            return []

        cte = cte_schema[name]
        resolved_cols = []
        alias_map = extract_alias_map(cte.get("source_tables", []))

        for col_alias, col_info in cte["columns"].items():
            col_expr = col_info["expression"]
            col_type = col_info["type"]

            if col_type == "star":
                for src_cte in cte.get("source_ctes", []):
                    resolved_cols.extend(resolve_cte(src_cte))
                for table in cte.get("source_tables", []):
                    base_table = alias_map.get(table, table)
                    resolved_cols.extend([f"{base_table}.{col}" for col in table_schema.get(base_table, [])])
            else:
                if "." in col_expr:
                    alias, col_name = col_expr.split(".", 1)
                    base_table = alias_map.get(alias, alias)
                    resolved_cols.append(f"{base_table}.{col_name}")
                else:
                    if len(cte["source_tables"]) == 1:
                        base_table = alias_map.get(cte["source_tables"][0], cte["source_tables"][0])
                        resolved_cols.append(f"{base_table}.{col_expr}")
                    else:
                        resolved_cols.append(f"{name}.{col_alias}")

        # Add passthrough columns from previous CTEs or base tables
        passthrough_cols = []
        for table in cte.get("source_tables", []):
            base_table = alias_map.get(table, table)
            if base_table in final_schema:
                passthrough_cols.extend(final_schema[base_table])
            elif base_table in table_schema:
                passthrough_cols.extend([f"{base_table}.{col}" for col in table_schema[base_table]])

        # De-duplicate and merge
        final_schema[name] = list(set(resolved_cols + passthrough_cols))
        return final_schema[name]

    

    # Resolve all CTEs first
    for cte in cte_schema:
        print(f"\nDEBUG: Resolving CTE {cte}")  # Debug
        resolve_cte(cte)

    # Resolve main SELECT
    print("\nDEBUG: Resolving main SELECT")  # Debug
    main = main_schema.get("main_select", {})
    print(f"DEBUG: Main select content: {main}")  # Debug
    main_cols = []
    
    # Create alias to table mapping
    alias_to_table = {}
    for table, alias in {**main.get("from_table", {}), **main.get("joins", {})}.items():
        alias_to_table[alias] = table
    print(f"DEBUG: alias_to_table: {alias_to_table}")  # Debug

    for col_alias, col_expr in main.get("columns", {}).items():
        print(f"\nDEBUG: Processing main column {col_alias}")  # Debug
        print(f"DEBUG: Column expr: {col_expr}")  # Debug
        
        if col_expr["is_star"]:
            print("DEBUG: Handling star in main select")  # Debug
            for tbl_alias in {**main["from_table"], **main["joins"]}.values():
                original_name = alias_to_table.get(tbl_alias, tbl_alias)
                if original_name in cte_schema:
                    main_cols.extend(resolve_cte(original_name))
                else:
                    main_cols.append(f"{original_name}.*")
        else:
            expr = col_expr["expression"]
            print(f"DEBUG: Processing expression: {expr}")  # Debug
            if expr is None:  # Debug
                print("WARNING: Main select expression is None!")  # Debug
                continue  # Debug
                
            if "." in expr:
                print("DEBUG: Expression has dot notation")  # Debug
                alias, col_name = expr.split(".", 1)
                true_table = alias_to_table.get(alias, alias)
                if true_table in cte_schema:
                    cte_cols = resolve_cte(true_table)
                    for col in cte_cols:
                        if col.endswith(f".{col_name}"):
                            main_cols.append(col)
                            break
                else:
                    main_cols.append(f"{true_table}.{col_name}")
            else:
                print("DEBUG: Simple expression in main select")  # Debug
                source_found = False
                for tbl_alias in {**main["from_table"], **main["joins"]}.values():
                    original_name = alias_to_table.get(tbl_alias, tbl_alias)
                    if original_name in cte_schema:
                        cte_cols = resolve_cte(original_name)
                        for col in cte_cols:
                            if col.endswith(f".{expr}"):
                                main_cols.append(col)
                                source_found = True
                                break
                    elif main.get("is_cte", {}).get(tbl_alias, False):
                        cte_cols = resolve_cte(original_name)
                        for col in cte_cols:
                            if col.endswith(f".{expr}"):
                                main_cols.append(col)
                                source_found = True
                                break
                if not source_found:
                    print("DEBUG: Using column alias as fallback")  # Debug
                    main_cols.append(col_alias)

    # Include all columns from FROM sources (CTEs or base tables)
    for tbl_alias in {**main["from_table"], **main["joins"]}.values():
        true_table = alias_to_table.get(tbl_alias, tbl_alias)
        if true_table in final_schema:
            main_cols.extend(final_schema[true_table])
        elif true_table in table_schema:
            main_cols.extend([f"{true_table}.{col}" for col in table_schema[true_table]])

    # Add explicitly selected ones too (like colz)
    final_schema["main_select"] = list(set(main_cols))

    print(f"\nDEBUG: Final schema: {final_schema}")  # Debug
    return final_schema

def expand_all_stars(ast: exp.Expression, resolved_schema: dict) -> exp.Expression:
    print("\n=== DEBUG: expand_all_stars ===")
    print(f"DEBUG: Resolved schema: {resolved_schema}")

    # Process CTEs first (bottom-up)
    if ast.args.get("with"):
        print("\nDEBUG: Processing CTEs")
        for cte in ast.args["with"].expressions:
            cte_name = cte.alias
            print(f"\nDEBUG: Processing CTE {cte_name}")
            if cte_name in resolved_schema:
                print(f"DEBUG: Found schema for CTE {cte_name}")
                print(f"DEBUG: Available columns: {resolved_schema[cte_name]}")
                print(f"DEBUG: Original CTE SQL: {cte.this.sql()}")
                
                # Create source aliases mapping
                source_aliases = {cte_name: cte_name}
                from_clause = cte.this.args.get("from")
                if from_clause:
                    for source in from_clause.expressions:
                        if isinstance(source, exp.Table):
                            table_name = source.name
                            alias = source.alias or table_name
                            source_aliases[table_name] = alias
                        elif isinstance(source, exp.Alias) and isinstance(source.this, exp.Table):
                            table_name = source.this.name
                            alias = source.alias
                            source_aliases[table_name] = alias
                
                print(f"DEBUG: Source aliases: {source_aliases}")
                expand_select_star(cte.this, resolved_schema[cte_name], source_aliases)
                print(f"DEBUG: Expanded CTE SQL: {cte.this.sql()}")
    
    # Process main query
    main_select = ast.find(exp.Select)
    if main_select and "main_select" in resolved_schema:
        print("\nDEBUG: Processing main SELECT")
        print(f"DEBUG: Original main SQL: {main_select.sql()}")
        print(f"DEBUG: Available columns: {resolved_schema['main_select']}")
        
        # Create source aliases mapping
        source_aliases = {}
        if main_select.args.get("from"):
            for source in main_select.args["from"].expressions:
                if isinstance(source, exp.Table):
                    table_name = source.name
                    alias = source.alias or table_name
                    source_aliases[table_name] = alias
                elif isinstance(source, exp.Alias) and isinstance(source.this, exp.Table):
                    table_name = source.this.name
                    alias = source.alias
                    source_aliases[table_name] = alias
        
        print(f"DEBUG: Source aliases: {source_aliases}")
        expand_select_star(main_select, resolved_schema["main_select"], source_aliases)
        print(f"DEBUG: Expanded main SQL: {main_select.sql()}")
    
    return ast

def expand_select_star(select: exp.Select, available_columns: list, source_aliases: dict):
    """
    Expands all star expressions (*) and qualified stars (table.*) in the SELECT clause.

    Args:
        select: The sqlglot Select expression object.
        available_columns: List of columns in the format 'table.column'.
        source_aliases: Dictionary mapping original table names to aliases used in the query.
    """
    new_exprs = []

    for expr in select.expressions:
        if isinstance(expr, exp.Star):
            # Unqualified star: expand to all available columns
            for col in available_columns:
                if "." not in col:
                    print(f"Warning: Skipping malformed column '{col}' in unqualified star expansion")
                    continue
                table_name, col_name = col.split(".", 1)
                new_exprs.append(
                    exp.Column(
                        this=exp.Identifier(this=col_name),
                        table=exp.Identifier(this=table_name)
                    )
                )

        elif isinstance(expr, exp.Column) and isinstance(expr.this, exp.Star):
            # Qualified star: expand only columns that match the table alias
            table_alias = expr.args["table"].this if hasattr(expr.args["table"], 'this') else expr.args["table"]

            for col in available_columns:
                if "." not in col:
                    print(f"Warning: Skipping malformed column '{col}' in qualified star expansion")
                    continue
                if col.startswith(f"{table_alias}."):
                    table_name, col_name = col.split(".", 1)
                    new_exprs.append(
                        exp.Column(
                            this=exp.Identifier(this=col_name),
                            table=exp.Identifier(this=table_name)
                        )
                    )
        else:
            # Keep all other expressions as-is
            new_exprs.append(expr)

    select.set("expressions", new_exprs)

    

def rename_columns_to_table_prefix(ast: exp.Expression, resolved_schema: dict, cte_schema: dict, table_schema: dict) -> exp.Expression:
    """
    Post-process the AST to replace table_alias.column or standalone column with table.column in SELECT clauses.
    
    Args:
        ast: The parsed SQL AST.
        resolved_schema: Schema for the main query (e.g., {"main_select": ["orders.id", "orders.amount"]}).
        cte_schema: Schema for CTEs (e.g., {"cte_name": {"columns": {"col": {"type": ..., "expression": ...}}}}).
        table_schema: Schema for base tables (e.g., {"orders": ["id", "amount"]}).
    
    Returns:
        Modified AST with columns renamed to table.column format.
    """
    def get_table_for_column(column: str, aliases: dict, schema: dict, cte_schema: dict, table_schema: dict) -> Optional[str]:
        """Determine the source table for a standalone column."""
        # Check final_schema for main query
        for col in schema.get("main_select", []):
            if col.endswith(f".{column}"):
                return col.split(".")[0]
        
        # Check cte_schema
        for cte, cte_info in cte_schema.items():
            for col_name, col_info in cte_info.get("columns", {}).items():
                if col_info.get("expression", "").endswith(f".{column}") or col_name == column:
                    expr = col_info.get("expression", col_name)
                    if "." in expr:
                        return expr.split(".")[0]
                    # If no table prefix, try to infer from source_tables
                    source_tables = cte_info.get("source_tables", [])
                    if len(source_tables) == 1:
                        return source_tables[0].split(" AS ")[0]
        
        # Check table_schema
        for table, columns in table_schema.items():
            if column in columns:
                return table
        
        return None

    def process_select_expressions(select: exp.Select, aliases: dict, schema: dict, cte_schema: dict, table_schema: dict) -> None:
        """Process SELECT expressions, replacing table_alias.column or column with table.column."""
        new_exprs = []
        for expr in select.args.get("expressions", []):
            if isinstance(expr, exp.Column):
                column_name = expr.this.this  # e.g., "id" from o.id or id
                table_alias = expr.args.get("table", None)  # e.g., "o" or None
                
                if table_alias:  # Handle table_alias.column (e.g., o.id)
                    alias_str = table_alias.this if isinstance(table_alias, exp.Identifier) else table_alias
                    # Find original table from aliases
                    for table_name, alias in aliases.items():
                        if alias == alias_str:
                            new_exprs.append(exp.Column(
                                this=exp.Identifier(this=column_name),
                                table=exp.Identifier(this=table_name)
                            ))
                            break
                    else:
                        # Keep original if no alias match
                        new_exprs.append(expr)
                else:  # Handle standalone column (e.g., id)
                    # Find source table from schemas
                    table_name = get_table_for_column(column_name, aliases, schema, cte_schema, table_schema)
                    if table_name:
                        new_exprs.append(exp.Column(
                            this=exp.Identifier(this=column_name),
                            table=exp.Identifier(this=table_name)
                        ))
                    else:
                        # Keep original if no table found
                        new_exprs.append(expr)
            else:
                new_exprs.append(expr)
        
        select.set("expressions", new_exprs)

    # Process CTEs
    if ast.args.get("with"):
        for cte in ast.args["with"].expressions:
            cte_name = cte.alias
            if cte_name in cte_schema:
                process_select_expressions(
                    cte.this,
                    {cte_name: cte_name},  # CTE uses its own name as alias
                    resolved_schema,
                    cte_schema,
                    table_schema
                )

    # Process main query
    main_select = ast.find(exp.Select)
    if main_select and "main_select" in resolved_schema:
        # Rebuild source_aliases
        source_aliases = {}
        if main_select.args.get("from"):
            from_clause = main_select.args["from"]
            if "this" in from_clause.args and isinstance(from_clause.args["this"], exp.Table):
                table = from_clause.args["this"]
                source_aliases[table.name] = table.alias or table.name
            for source in from_clause.expressions:
                if isinstance(source, exp.Table):
                    source_aliases[source.name] = source.alias or source.name
                elif isinstance(source, exp.Alias) and isinstance(source.this, exp.Table):
                    source_aliases[source.this.name] = source.alias
        
        process_select_expressions(
            main_select,
            source_aliases,
            resolved_schema,
            cte_schema,
            table_schema
        )

    return ast


# def rename_columns_to_table_prefix(ast: exp.Expression, resolved_schema: dict, cte_schema: dict, table_schema: dict) -> exp.Expression:
#     """
#     Post-process the AST to replace table_alias.column or standalone column with table.column in SELECT clauses.
    
#     Args:
#         ast: The parsed SQL AST.
#         resolved_schema: Schema for the main query (e.g., {"main_select": ["orders.id", "orders.amount"]}).
#         cte_schema: Schema for CTEs (e.g., {"cte_name": {"columns": {"col": {"type": ..., "expression": ...}}}}).
#         table_schema: Schema for base tables (e.g., {"orders": ["id", "amount"]}).
    
#     Returns:
#         Modified AST with columns renamed to table.column format.
#     """
#     def get_table_for_column(column: str, aliases: dict, schema: dict, cte_schema: dict, table_schema: dict) -> Optional[str]:
#         """Determine the source table for a standalone column."""
#         # Check final_schema for main query
#         for col in schema.get("main_select", []):
#             if col.endswith(f".{column}"):
#                 return col.split(".")[0]
        
#         # Check cte_schema
#         for cte, cte_info in cte_schema.items():
#             for col_name, col_info in cte_info.get("columns", {}).items():
#                 if col_info.get("expression", "").endswith(f".{column}") or col_name == column:
#                     expr = col_info.get("expression", col_name)
#                     if "." in expr:
#                         return expr.split(".")[0]
#                     # If no table prefix, try to infer from source_tables
#                     source_tables = cte_info.get("source_tables", [])
#                     if len(source_tables) == 1:
#                         return source_tables[0].split(" AS ")[0]
        
#         # Check table_schema
#         for table, columns in table_schema.items():
#             if column in columns:
#                 return table
        
#         return None

#     def process_select_expressions(select: exp.Select, aliases: dict, schema: dict, cte_schema: dict, table_schema: dict) -> None:
#         """Process SELECT expressions, replacing table_alias.column or column with table.column."""
#         new_exprs = []
#         for expr in select.args.get("expressions", []):
#             if isinstance(expr, exp.Column):
#                 column_name = expr.this.this  # e.g., "id" from o.id or id
#                 table_alias = expr.args.get("table", None)  # e.g., "o" or None
                
#                 if table_alias:  # Handle table_alias.column (e.g., o.id)
#                     alias_str = table_alias.this if isinstance(table_alias, exp.Identifier) else table_alias
#                     # Find original table from aliases
#                     for table_name, alias in aliases.items():
#                         if alias == alias_str:
#                             new_exprs.append(exp.Column(
#                                 this=exp.Identifier(this=column_name),
#                                 table=exp.Identifier(this=table_name)
#                             ))
#                             break
#                     else:
#                         # Keep original if no alias match
#                         new_exprs.append(expr)
#                 else:  # Handle standalone column (e.g., id)
#                     # Find source table from schemas
#                     table_name = get_table_for_column(column_name, aliases, schema, cte_schema, table_schema)
#                     if table_name:
#                         new_exprs.append(exp.Column(
#                             this=exp.Identifier(this=column_name),
#                             table=exp.Identifier(this=table_name)
#                         ))
#                     else:
#                         # Keep original if no table found
#                         new_exprs.append(expr)
#             else:
#                 new_exprs.append(expr)
        
#         select.set("expressions", new_exprs)

#     # Process CTEs
#     if ast.args.get("with"):
#         for cte in ast.args["with"].expressions:
#             cte_name = cte.alias
#             if cte_name in cte_schema:
#                 process_select_expressions(
#                     cte.this,
#                     {cte_name: cte_name},  # CTE uses its own name as alias
#                     resolved_schema,
#                     cte_schema,
#                     table_schema
#                 )

#     # Process main query
#     main_select = ast.find(exp.Select)
#     if main_select and "main_select" in resolved_schema:
#         # Rebuild source_aliases
#         source_aliases = {}
#         if main_select.args.get("from"):
#             from_clause = main_select.args["from"]
#             if "this" in from_clause.args and isinstance(from_clause.args["this"], exp.Table):
#                 table = from_clause.args["this"]
#                 source_aliases[table.name] = table.alias or table.name
#             for source in from_clause.expressions:
#                 if isinstance(source, exp.Table):
#                     source_aliases[source.name] = source.alias or source.name
#                 elif isinstance(source, exp.Alias) and isinstance(source.this, exp.Table):
#                     source_aliases[source.this.name] = source.alias
        
#         process_select_expressions(
#             main_select,
#             source_aliases,
#             resolved_schema,
#             cte_schema,
#             table_schema
#         )

#     return ast

def wrap_select_with_insert(
    sql: str,
    filename: Optional[str] = None,
    column_list: Optional[List[str]] = None,
    replacements: Optional[Dict] = None
) -> str:
    """
    Wraps a SELECT query with INSERT INTO statement using filename as table name.
    
    Args:
        sql: The SQL query to wrap (must be star-expanded already)
        filename: SQL filename (e.g., 'orders.sql' â†’ becomes 'orders')
        column_list: Explicit column list for INSERT (optional)
        replacements: Dictionary of string replacements (optional)
    
    Returns:
        SQL with INSERT INTO prepended
    """
    try:
        # Apply replacements if provided
        if replacements:
            for old, new in replacements.items():
                sql = sql.replace(old, new)
        
        ast = parse_sql_cached(sql)
        main_select = ast.find(exp.Select)
        
        if not main_select:
            raise ValueError("No SELECT found in query")
        
        # Determine target table name from filename
        if filename:
            target_table = os.path.splitext(os.path.basename(filename))[0]
            target_table = re.sub(r'[^a-zA-Z0-9_]', '_', target_table)
        else:
            target_table = "output_table"
        
        # Get or validate column list
        if column_list:
            print('column_list',column_list)
            # Verify column count matches SELECT
            if len(column_list) != len(main_select.expressions):
                raise ValueError(f"Column list length ({len(column_list)}) doesn't match SELECT columns ({len(main_select.expressions)})")
        else:
            # Generate from SELECT expressions
            column_list = []
            for expr in main_select.expressions:
                if isinstance(expr, exp.Alias):
                    column_list.append(expr.alias)
                elif isinstance(expr, exp.Column):
                    column_list.append(expr.name)
                else:
                    column_list.append(expr.sql())

        column_list = [col.split(".")[1] if '.' in col else col for col in column_list]  # Remove table prefix if any
        
        # Build final SQL
        insert_stmt = f"INSERT INTO {target_table}"
        return f"{insert_stmt}\n{ast.sql()}"
    
    except Exception as e:
        print(f"Warning: Couldn't wrap query - {str(e)}")
        return sql  # Fallback to original
    

def clean_lineage_tuple(variable: List[str]) -> List[str]:
    """Cleans lineage tuples by removing default schema references."""
    return [v.replace('<default>.', '') for v in variable]

def extract_column_lineage(processed_sql: str) -> pd.DataFrame:
    """Extracts column lineage from SQL query."""
    try:       
        # Extract lineage
        lineage_mapping = []
        lineage_data = LineageRunner(processed_sql).get_column_lineage()
        print(f"Extracted lineage data: {lineage_data}")
        for lineage_tuple in lineage_data:
            try:
                chain = [str(col) for col in lineage_tuple]
                cleaned_chain = clean_lineage_tuple(chain)

                print(f"Cleaned lineage chain: {cleaned_chain}")
                
                for i in range(len(cleaned_chain) - 1):
                    target = cleaned_chain[i]
                    source = cleaned_chain[i + 1]
                    
                    lineage_mapping.append((
                        target if len(target.split('.')) == 2 else f"<unknown>.{target}",
                        source if len(source.split('.')) == 2 else f"<unknown>.{source}"
                    ))
            except Exception as e:
                print(f"Skipping lineage tuple due to error: {str(e)}")
                continue
        
        # Create DataFrame
        lineage_df = pd.DataFrame(lineage_mapping, columns=["derived", "source"])
        lineage_df[['derived_table', 'derived_column']] = lineage_df['derived'].str.split('.', expand=True)
        lineage_df[['source_table', 'source_column']] = lineage_df['source'].str.split('.', expand=True)
        
        return lineage_df[['source_table', 'source_column', 'derived_table', 'derived_column']].drop_duplicates()
    
    except Exception as e:
        print(f"Lineage extraction failed: {str(e)}")
        return pd.DataFrame()
    
def process_single_sql(sql: str, filename: str, replacements: dict) -> tuple:
    # 1. Apply replacements
    for old, new in replacements.items():
        sql = sql.replace(old, new)

    print(f"Processing SQL file: {filename}")
    
    # 2. Clean and parse
    cleaned_sql = format_and_clean_sql(sql)
    ast = parse_sql_cached(cleaned_sql)

    print(f"Parsed SQL AST: {ast.sql()}")
    
    # 3. Schema resolution
    cte_schemas = get_cte_schemas(ast)
    main_schema = extract_main_table_schema(ast, set(cte_schemas.keys()))
    final_schema = resolve_recursive_schema(cte_schemas, main_schema)

    print(f"Resolved schema: {final_schema}")
    print(f"CTE schemas: {cte_schemas}")
    print(f"Main schema: {main_schema}")
    
    # 4. Star expansion - Make sure expand_all_stars returns only the AST
    expanded_ast = expand_all_stars(ast, final_schema)
    print(f"Expanded SQL AST: {expanded_ast.sql()}")

    # 5. Rename columns to table prefix
    renamed_ast = rename_columns_to_table_prefix(expanded_ast, final_schema, cte_schemas, main_schema)
    expanded_sql = renamed_ast.sql()

    print(f"Renamed SQL AST: {expanded_sql}")
    
    # 6. Add INSERT wrapper
    wrapped_sql = wrap_select_with_insert(
        expanded_sql,
        filename=os.path.splitext(filename)[0],
        column_list=final_schema["main_select"],
        replacements=replacements
    )

    print(f"Wrapped SQL: {wrapped_sql}")
    
    # 7. Extract lineage
    lineage_df = extract_column_lineage(wrapped_sql)
    
    return wrapped_sql, lineage_df

def process_sql_file(file_path: str, replacements: Dict) -> pd.DataFrame:
    """Processes a single SQL file and returns lineage DataFrame."""
    try:
        with open(file_path, 'r') as f:
            sql = f.read().strip()
            if not sql:
                print(f"Skipping empty file: {file_path}")
                return pd.DataFrame()
            
            # Get just the filename without path
            filename = os.path.basename(file_path)
            _, lineage_df = process_single_sql(sql, filename, replacements)
            return lineage_df
    except Exception as e:
        print(f"Error processing {file_path}: {str(e)}")
        return pd.DataFrame()

def process_sql_folder(folder_path: str, replacements: Dict) -> pd.DataFrame:
    """Processes all SQL files in a folder and returns combined lineage."""
    sql_files = [
        os.path.join(folder_path, f) 
        for f in os.listdir(folder_path) 
        if f.endswith('.sql')
    ]
    
    # Process files in parallel
    with ThreadPoolExecutor() as executor:
        results = list(executor.map(
            lambda f: process_sql_file(f, replacements), 
            sql_files
        ))
    
    return pd.concat(results).drop_duplicates().reset_index(drop=True)

# Example usage
if __name__ == "__main__":
    replacements = {
        '[$target_dataset].': '',
        '"[$run_type]"': 'runtype',
        "'[$run_type]'": 'runtype',
        '[$regulator_table]': 'EBA'
    }
    
    folder_path = r"C:\User_Profiles\Keval\Projects\parser\sql_files"
    master_lineage_df = process_sql_folder(folder_path, replacements)
    print(f"Processed {len(master_lineage_df)} lineage records")




