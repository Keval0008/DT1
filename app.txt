import dash
from dash import dcc, html, Input, Output, State, callback
import dash_bootstrap_components as dbc
from concurrent.futures import ThreadPoolExecutor
import pandas as pd
import time

# Your existing SQLLineageProcessor class here

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

app.layout = dbc.Container([
    dcc.Input(id="folder-path", placeholder="Enter folder path", type="text"),
    dbc.Button("Generate Lineage", id="process-btn", color="primary"),
    html.Div(id="status-log", style={"whiteSpace": "pre-line"}),
    dcc.Loading(
        id="loading-spinner",
        type="circle",
        children=[dcc.Progress(id="progress-bar", value=0)]
    ),
    html.Div(id="dummy-div", style={"display": "none"}),  # For triggering downloads
    dcc.Download(id="download-csv")
])

# Callback for processing + status updates
@app.callback(
    [Output("status-log", "children"),
     Output("progress-bar", "value"),
     Output("download-csv", "data")],
    Input("process-btn", "n_clicks"),
    State("folder-path", "value"),
    prevent_initial_call=True
)
def process_and_update_status(n_clicks, folder_path):
    if not folder_path:
        return "Error: No folder path provided", 0, None

    ctx = dash.callback_context
    if not ctx.triggered:
        return dash.no_update

    # Initialize processor
    processor = SQLLineageProcessor()
    status_log = []
    
    # Stage 1: File discovery
    status_log.append("üîç Scanning folder for SQL files...")
    yield "\n".join(status_log), 10, None
    
    sql_files = [f for f in os.listdir(folder_path) if f.endswith('.sql')]
    if not sql_files:
        return "‚ùå No SQL files found!", 0, None
    
    status_log.append(f"üìÇ Found {len(sql_files)} files to process")
    yield "\n".join(status_log), 20, None

    # Stage 2: Parallel processing
    status_log.append("\n‚öôÔ∏è Processing files (0% complete)...")
    yield "\n".join(status_log), 20, None

    def update_progress(future):
        nonlocal status_log
        completed = sum(1 for f in futures if f.done())
        progress = int(100 * (completed / len(sql_files)))
        status_log[-1] = f"‚öôÔ∏è Processing files ({progress}% complete)..."
        return progress

    with ThreadPoolExecutor() as executor:
        futures = [executor.submit(processor.process_sql_file, os.path.join(folder_path, f)) 
                  for f in sql_files]
        
        while not all(f.done() for f in futures):
            progress = update_progress(futures)
            yield "\n".join(status_log), 20 + (progress * 0.6), None
            time.sleep(0.1)

    # Stage 3: Compile results
    status_log.append("\nüß© Compiling master lineage...")
    yield "\n".join(status_log), 90, None

    master_lineage = processor.get_master_lineage()
    status_log.append(f"‚úÖ Done! Processed {len(sql_files)} files. Found {len(master_lineage)} lineage edges.")
    
    # Return final status + CSV download
    return (
        "\n".join(status_log),
        100,
        dict(content=master_lineage.to_csv(index=False), filename="lineage_results.csv")
    )

if __name__ == "__main__":
    app.run_server(debug=True)
