import numpy as np
import pandas as pd
from typing import Iterable

def normalize_and_move_multiindex_tail(df: pd.DataFrame, specials: Iterable[str]) -> pd.DataFrame:
    """
    For a 3-level MultiIndex columns DF:
      - If a column is (X, NaN/blank, NaN/blank) where X âˆˆ specials,
        rename it to (NaN, NaN, X).
      - Then move all (NaN, NaN, X) columns to the end in the given order (skip missing).
    """
    if not isinstance(df.columns, pd.MultiIndex) or df.columns.nlevels < 3:
        raise ValueError("This function expects a DataFrame with 3-level MultiIndex columns.")

    specials = list(specials)  # preserve order

    def is_empty(x) -> bool:
        if x is None:
            return True
        try:
            if pd.isna(x):
                return True
        except Exception:
            pass
        return isinstance(x, str) and (x.strip() == "" or x.strip().lower() == "nan")

    def match_singleton(col_tup, target: str) -> bool:
        """True if exactly one non-empty element equals target."""
        non_empty = [(i, v) for i, v in enumerate(col_tup) if not is_empty(v)]
        if len(non_empty) != 1:
            return False
        _, v = non_empty[0]
        return str(v).strip() == str(target).strip()

    # --- 1) Canonicalize with callable: ("X", NA, NA) -> (NA, NA, "X")
    def canonicalize(col):
        for X in specials:
            if match_singleton(col, X):
                return (np.nan, np.nan, X)
        return col

    out = df.copy()
    out = out.rename(columns=canonicalize)

    # --- 2) Move canonical columns to the end in the caller's order
    def is_canonical(col_tup, X: str) -> bool:
        return is_empty(col_tup[0]) and is_empty(col_tup[1]) and str(col_tup[2]).strip() == str(X).strip()

    tail = []
    for X in specials:
        tail.extend([c for c in out.columns if is_canonical(c, X)])

    others = [c for c in out.columns if c not in tail]
    out = out.loc[:, others + tail]
    return out
