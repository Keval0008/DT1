# pip install --upgrade msoffcrypto-tool pandas openpyxl xlrd pyxlsb olefile cryptography
import os
import io
import sys
import tempfile
from pathlib import Path
from getpass import getpass

import pandas as pd
import msoffcrypto

try:
    from msoffcrypto.exceptions import InvalidKeyError
except Exception:
    class InvalidKeyError(Exception):
        pass

SUPPORTED_EXTS = {".xlsx", ".xlsm", ".xls", ".xlsb"}

def _pick_engine(ext: str) -> str:
    ext = ext.lower()
    if ext in (".xlsx", ".xlsm"):
        return "openpyxl"
    if ext == ".xls":
        return "xlrd"
    if ext == ".xlsb":
        return "pyxlsb"
    raise ValueError(f"Unsupported extension: {ext}")

def _decrypt_to_temp(path: Path, password: str, ext: str) -> str:
    """Decrypts the file to a temporary file and returns its path."""
    with open(path, "rb") as f:
        of = msoffcrypto.OfficeFile(f)
        of.load_key(password=password)
        with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
            tmp_name = tmp.name
            of.decrypt(tmp)
    return tmp_name

def _is_encrypted(path: Path) -> bool:
    with open(path, "rb") as f:
        of = msoffcrypto.OfficeFile(f)
        return bool(getattr(of, "is_encrypted", True))  # default True for safety

def read_excel_all_sheets(path: str | Path, password: str | None = None, max_tries: int = 3) -> dict:
    """
    Returns a dict: {sheet_name: DataFrame} for the provided Excel file.
    If the file is read-password protected and no password is provided,
    it will prompt (masked) up to max_tries times.

    Parameters
    ----------
    path : str | Path
    password : str | None
        Open/read password. If None and file is encrypted, you'll be prompted.
    max_tries : int
        How many times to prompt for a password if the first attempt fails.
    """
    path = Path(path)
    ext = path.suffix.lower()
    if ext not in SUPPORTED_EXTS:
        raise ValueError(f"Unsupported file type: {ext}. Supported: {', '.join(sorted(SUPPORTED_EXTS))}")

    engine = _pick_engine(ext)

    # If not encrypted, read directly
    if not _is_encrypted(path):
        return pd.read_excel(path, sheet_name=None, engine=engine)

    # If encrypted, get (or ask for) password and try decrypting
    tries = 0
    last_err = None
    while tries < max_tries:
        pw = password
        if not pw:
            # Show filename in prompt
            pw = getpass(f"Enter OPEN password for '{path.name}': ")

        try:
            tmp_name = _decrypt_to_temp(path, pw, ext)
            try:
                # Read all sheets
                dfs = pd.read_excel(tmp_name, sheet_name=None, engine=engine)
                return dfs
            finally:
                try:
                    os.remove(tmp_name)
                except OSError:
                    pass
        except InvalidKeyError as e:
            print("Password incorrect. Please try again.", file=sys.stderr)
            last_err = e
            password = None  # force prompt again
            tries += 1
        except Exception as e:
            # Any other decryption error
            raise RuntimeError(f"Failed to decrypt '{path.name}': {e}") from e

    raise InvalidKeyError(f"Failed to open '{path.name}' after {max_tries} attempts (wrong password).")

# ----------------------- Example usage -----------------------
# dfs = read_excel_all_sheets("your_file.xlsx")
# for sheet, df in dfs.items():
#     print(f"\n--- {sheet} ---")
#     print(df.head())
